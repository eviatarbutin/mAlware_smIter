import numpy as np
from math import sqrt, ceil
import cv2
import tkinter as tk
from tkinter.filedialog import askopenfilename
from tkinter import filedialog as fd
import socket

import threading
from constants import *
import os

#global variables to work with gui buttons and more
is_file_selected = False
filename_selected = "default.png"

grey_scale_image = False
got_answer = False
answer = ""
canvas = ''
message = ""
server_public_key = ""


def convert_file_to_image(path:str):
    #Read the whole file to data
    with open(path, 'rb') as binary_file:        
        data = binary_file.read()

    # Data length in bytes
    data_len = len(data)

    # d is a verctor of data_len bytes
    d = np.frombuffer(data, dtype=np.uint8)

    # Assume image shape should be close to square
    sqrt_len = int(ceil(sqrt(data_len)))  # Compute square toot and round up

    # Requiered length in bytes.
    new_len = sqrt_len*sqrt_len

    # Number of bytes to pad (need to add zeros to the end of d)
    pad_len = new_len - data_len

    # Pad d with zeros at the end.
    # padded_d = np.pad(d, (0, pad_len))
    padded_d = np.hstack((d, np.zeros(pad_len, np.uint8)))

    # Reshape 1D array into 2D array with sqrt_len pad_len x sqrt_len (im is going to be a Grayscale image).
    im = np.reshape(padded_d, (sqrt_len, sqrt_len))
    im = cv2.resize(im, FIXED_SIZE)

    # Save image
    cv2.imwrite('temp.png', im)
    return "temp.png"

#send the image file to the server for it to analyze it

def send_file(path:str, socket: socket.socket):
    if os.path.isfile(path):
        with open(path, "rb") as file:
            content = file.read()
            #calculating in how many packets the file will be sent
            number_of_packets = len(content) // BUFFER_SIZE + (1 if len(content) % BUFFER_SIZE != 0 else 0)
            try:
                bytes_number_of_packets = number_of_packets.to_bytes(2, "big")        
            except:
                exit("File too large to be sent")
            #sending amount of packets
            socket.send(bytes_number_of_packets)
            #sending file
            for packet_index in range(number_of_packets):
                socket.send(content[packet_index*BUFFER_SIZE: (packet_index+1) * BUFFER_SIZE])



def GUI():
    #getting global variables
    global filename_selected
    global canvas
    global message
    #creating gui
    root = tk.Tk()
    root.title("mAlware smIter")
    root.geometry("1000x1000")
    #greeting the user
    greetings = tk.Label(root, text="Hello and welcome to mAlware smIter!")
    greetings.pack()
    #giving instruction on how to use the application
    instructions = tk.Label(root, text="Please choose the file you want to check which malware family it is part of!")
    instructions.pack()
    message = tk.Label(root, text="The family is: ")
    message.pack()

    # Button : Open to open the file that you want to test
    open = tk.Button(root, text = "Open", command = open_file_chooser)
    open.pack()
    open_image = tk.Button(root, text = "Open Image", command = open_image_chooser)
    open_image.pack()

    # the image of the file just for entartainment
    canvas = tk.Canvas(root, width = 1000, height = 1000)      
    canvas.pack()      
    #putting an image
    img = tk.PhotoImage(file=filename_selected)      
    canvas.create_image(20,20, anchor=tk.NW, image=img)      



    # Starting the Application
    root.mainloop()


# defining open_file_chooser function
def open_image_chooser():
    global filename_selected
    global is_file_selected
    global grey_scale_image
    filename_selected = askopenfilename()
    is_file_selected = True
    grey_scale_image = True
    print("You have selected : %s" % filename_selected)

def open_file_chooser():
    global filename_selected
    global is_file_selected
    global grey_scale_image
    filename_selected = askopenfilename()
    is_file_selected = True
    grey_scale_image = False
    print("You have selected : %s" % filename_selected)


#running in thread and checking if user chose a file if a file was chosen it is sent and waits for an answer
def send_chosen_file(socket):
    global filename_selected
    global is_file_selected
    global answer
    global got_answer
    global canvas

    while True:
        # if file was selected from the gui we send the selected file
        if is_file_selected:
            is_file_selected = False
            #converting the file to image first
            if not grey_scale_image:
                image_path = convert_file_to_image(filename_selected)
            else:
                image_path = filename_selected
            img = tk.PhotoImage(file=image_path)
            message.config(text="Here you can see the grey scale image of the file you've chosen!")
            print("pizdez")
            
            canvas.delete("all")
            #showing the image just for fun
            canvas.create_image(20,20, anchor=tk.NW,image=img) 
            #sending the image
            send_file(image_path,socket)
            response = socket.recv(BUFFER_SIZE).decode()
            print(response)
            message.config(text=response)


#connecting to server
def connect_client() -> socket.socket:
    client = socket.socket()
    client.connect((CLIENT_IP,PORT))
    return client

def main():
    #generating keys
    #connecting to server
    client = connect_client()
    #send publick key
    #sending file and initiating gui
    send_file(PUBLICK_CLIENT,client)
    client
    send_file_thread = threading.Thread(target=send_chosen_file,args=(client,))
    send_file_thread.start()
    
    GUI()
    send_file.join()

if __name__ == "__main__":
    main()
