import numpy as np
from math import sqrt, ceil
import cv2
import tkinter as tk
from tkinter.filedialog import askopenfilename
from tkinter import filedialog as fd
from tkinter.messagebox import showinfo
import socket

from rsa import PrivateKey
from cryptography import *
import threading
from PIL import ImageTk, Image
from constants import *

#global variables to work with gui buttons and more
is_file_selected = False
filename_selected = "default.png"

got_answer = False
answer = ""
canvas = ''
message = ""
server_public_key = ""


def convert_file_to_image(path:str):
    #Read the whole file to data
    with open(path, 'rb') as binary_file:        
        data = binary_file.read()

    # Data length in bytes
    data_len = len(data)

    # d is a verctor of data_len bytes
    d = np.frombuffer(data, dtype=np.uint8)

    # Assume image shape should be close to square
    sqrt_len = int(ceil(sqrt(data_len)))  # Compute square toot and round up

    # Requiered length in bytes.
    new_len = sqrt_len*sqrt_len

    # Number of bytes to pad (need to add zeros to the end of d)
    pad_len = new_len - data_len

    # Pad d with zeros at the end.
    # padded_d = np.pad(d, (0, pad_len))
    padded_d = np.hstack((d, np.zeros(pad_len, np.uint8)))

    # Reshape 1D array into 2D array with sqrt_len pad_len x sqrt_len (im is going to be a Grayscale image).
    im = np.reshape(padded_d, (sqrt_len, sqrt_len))
    im = cv2.resize(im, FIXED_SIZE)

    # Save image
    cv2.imwrite('temp.png', im)
    return "temp.png"

#send the image file to the server for it to analyze it
def send_file(path:str, socket: socket.socket):
    if os.path.isfile(path):
        with open(path, "rb") as file:
            content = file.read()
            #calculating in how many packets the file will be sent
            number_of_packets = len(content) // BUFFER_SIZE + (1 if len(content) % BUFFER_SIZE != 0 else 0)
            try:
                bytes_number_of_packets = number_of_packets.to_bytes(2, "big")        
            except:
                exit("File to large to be sent")
            #sending amount of packets
            socket.send(encrypt(bytes_number_of_packets,server_public_key))
            #sending file
            for packet_index in range(number_of_packets):
                socket.send(encrypt(content[packet_index*BUFFER_SIZE: (packet_index+1) * BUFFER_SIZE],server_public_key))
    else:
        print("error not a file")

def GUI():
    #getting global variables
    global filename_selected
    global canvas
    global message
    #creating gui
    root = tk.Tk()
    root.title("mAlware smIter")
    root.geometry("1000x1000")
    #greeting the user
    greetings = tk.Label(root, text="Hello and welcome to mAlware smIter!")
    greetings.pack()
    #giving instruction on how to use the application
    message = tk.Label(root, text="Please choose the file you want to check which malware family it is part of!")
    message.pack()

    # Button : Open to open the file that you want to test
    open = tk.Button(root, text = "Open", command = open_file_chooser)
    open.pack()
    # the image of the file just for entartainment
    canvas = tk.Canvas(root, width = 1000, height = 1000)      
    canvas.pack()      
    #putting an image
    img = tk.PhotoImage(file=filename_selected)      
    canvas.create_image(20,20, anchor=tk.NW, image=img)      

    # Starting the Application
    root.mainloop()

#recieving servers publick key
def get_server_publick_key(client: socket.socket,key:PrivateKey):
    file_name = "server_publick.pem"
    data += decrypt(client.recv(2*BUFFER_SIZE))
    with open(file_name, "wb") as file:
        file.write(data)
    return file_name


# defining open_file_chooser function
def open_file_chooser():
    global filename_selected
    global is_file_selected
    filename_selected = askopenfilename()
    is_file_selected = True
    print("You have selected : %s" % filename_selected)

#running in thread and checking if user chose a file if a file was chosen it is sent and waits for an answer
def send_chosen_file(socket,private_key):
    global filename_selected
    global is_file_selected
    global answer
    global got_answer
    global canvas

    while True:
        # if file was selected from the gui we send the selected file
        if is_file_selected:
            is_file_selected = False
            #converting the file to image first
            image_path =  convert_file_to_image(filename_selected)
            img = tk.PhotoImage(file=image_path)
            message.config(text="Here you can see the grey scale image of the file you've chosen!")

            canvas.delete("all")
            #showing the image just for fun
            canvas.create_image(20,20, anchor=tk.NW,image=img) 
            #sending the image
            send_file(image_path,socket)
            message.config(text=decrypt(socket.recv(BUFFER_SIZE),private_key).decode())


#connecting to server
def connect_client() -> socket.socket:
    client = socket.socket()
    client.connect((CLIENT_IP,PORT))
    return client

def main():
    #generating keys
    global server_public_key
    generateKeys(PUBLICK_CLIENT, PRIVATE_CLIENT)
    public_key, private_key = loadKeys(PUBLICK_CLIENT, PRIVATE_CLIENT)
    #connecting to server
    client = connect_client()
    #send publick key
    #sending file and initiating gui
    send_file(PUBLICK_CLIENT,client)
    get_server_publick_key(client,private_key)
    server_public_key = loadKey("server_publick.pem", True)
    send_file = threading.Thread(target=send_chosen_file,args=(client,private_key,))
    send_file.start()
    
    GUI()
    send_file.join()

if __name__ == "__main__":
    main()
