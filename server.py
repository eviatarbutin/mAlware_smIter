import socket

import torch
from constants import *
from create_dataset import create_dataset
from neural_network import SimpleCNN, split_dataset1, test_cnn, train_cnn, test_file
from our_dataset import OurDataset


#get one user to the server
def get_user(server: socket.socket):
    server.listen(NUMBER_OF_USERS)
    return server.accept()
    
#get an encrypted image and save it as 
def get_file(client: socket.socket):
    file_name = TESTED_FILE
    #get image length in packets
    bytes_number_of_packets = client.recv(BUFFER_SIZE)
    if bytes_number_of_packets == b"":
        print("pusto")
        raise "closed connection"
    number_of_packets = int.from_bytes(bytes_number_of_packets,"big")
    data: bytes = b""
    #get the image
    for packet_index in range(number_of_packets):
        data += client.recv(BUFFER_SIZE)
    #save the image
    with open(file_name, "wb+") as file:
        file.write(data)

# recieve the publick key of the client

    


def main():
    #create a pair of rsa keys
    #load them into objects
    #create a dataset
    dataset = create_dataset()
    # #split the dataset into train and test
    # train_set, test_set = split_dataset1(dataset)
    # #load the dataset with the dataloader
    # train_loader = torch.utils.data.DataLoader(train_set, batch_size=1,
    #                                       shuffle=True, num_workers=2)
    # #load the dataset with the dataloader
    # test_loader = torch.utils.data.DataLoader(test_set, batch_size=1,
    #                                       shuffle=False, num_workers=2)
    #create the cnn module
    print("dataset loaded")
    cnn = SimpleCNN()
    cnn.load_state_dict(torch.load("state_dict.pt"))
    
    #train the module
    # train_cnn(train_loader, cnn)
    # #test the module
    # test_cnn(test_loader, cnn)
    print("cnn loaded")
    #create server
    server = socket.socket()
    server.bind((SERVER_IP, PORT))
    while True:
        print("waiting for client")
        #get client
        client, client_address = get_user(server)
        #get clients publick key
        # load it
        #send ours publick key
        # with open(PUBLICK_SERVER,"rb") as key:
        #     content = key.read()
        #     number_of_packets = len(content) // BUFFER_SIZE + (1 if len(content) % BUFFER_SIZE != 0 else 0)
        #     bytes_number_of_packets = number_of_packets.to_bytes(2, "big")        
        #     client.send(bytes_number_of_packets)
        #     for packet_index in range(number_of_packets):
        #         client.send(key.read())
        #get files analyze them and send the results
        while True:
            try:
                get_file(client)
            except:
                break
            dataset.__add__(TESTED_FILE)
            answer = test_file(dataset.__getitem__(-1), cnn)
            print(answer.item())
            answer = dataset.get_family_based_on_index(answer.item())
            client.send(answer.encode())

if __name__ == "__main__":
    main()